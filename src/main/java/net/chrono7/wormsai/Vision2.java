//package net.chrono7.wormsai;
//
//import boofcv.alg.filter.binary.BinaryImageOps;
//import boofcv.alg.filter.binary.Contour;
//import boofcv.alg.filter.binary.GThresholdImageOps;
//import boofcv.gui.ListDisplayPanel;
//import boofcv.gui.binary.VisualizeBinaryData;
//import boofcv.io.UtilIO;
//import boofcv.io.image.ConvertBufferedImage;
//import boofcv.io.image.UtilImageIO;
//import boofcv.struct.ConnectRule;
//import boofcv.struct.image.GrayF32;
//import boofcv.struct.image.GrayS32;
//import boofcv.struct.image.GrayU8;
//
//import java.awt.image.BufferedImage;
//import java.util.Arrays;
//import java.util.List;
//
//public class Vision2 {
//
//    // Used to bias it towards more or fewer sides. larger number = fewer sides
//    static double cornerPenalty = 0.25;
//    // The fewest number of pixels a side can have
//    static int minSide = 10;
//
//    static ListDisplayPanel gui = new ListDisplayPanel();
//
//    /**
//     * Detects contours inside the binary image generated by canny.  Only the external contour is relevant. Often
//     * easier to deal with than working with Canny edges directly.
//     */
////    public static void fitCannyBinary( GrayF32 input ) {
////
////        BufferedImage displayImage = new BufferedImage(input.width,input.height,BufferedImage.TYPE_INT_RGB);
////        GrayU8 binary = new GrayU8(input.width,input.height);
////
////        GrayF32 sharpened = input.createSameShape();
////        EnhanceImageOps.sharpen8(input, sharpened);
////
////        GrayF32 brightened = input.createSameShape();
////        GrayImageOps.stretch(input, 10, 0, 255, brightened);
////
////        gui.addImage(brightened, "brightened");
////
////        // Finds edges inside the image
////        CannyEdge<GrayF32,GrayF32> canny =
////                FactoryEdgeDetectors.canny(3, false, true, GrayF32.class, GrayF32.class);
////
////        canny.process(input,0.001f,0.2f,binary);
////
////        List<Contour> contours = BinaryImageOps.contour(binary, ConnectRule.EIGHT, null);
////
////        Graphics2D g2 = displayImage.createGraphics();
////        g2.setStroke(new BasicStroke(2));
////
////        // used to select colors for each line
////        Random rand = new Random(234);
////
////        for( Contour c : contours ) {
////            // Only the external contours are relevant.
////            List<PointIndex_I32> vertexes = ShapeFittingOps.fitPolygon(c.external,true, minSide,cornerPenalty);
////
////            g2.setColor(new Color(rand.nextInt()));
////            VisualizeShapes.drawPolygon(vertexes,true,g2);
////        }
////
////        gui.addImage(displayImage, "Canny Contour");
////    }
////
////    public static void main( String args[] ) {
////        // load and convert the image into a usable format
////        BufferedImage image = UtilImageIO.loadImage(UtilIO.pathExample("C:\\Users\\Brian\\IdeaProjects\\WormsAI\\vision2.png"));
////        GrayF32 input = ConvertBufferedImage.convertFromSingle(image, null, GrayF32.class);
////
////        gui.addImage(image,"Original");
////
////        fitCannyBinary(input);
////
////        ShowImages.showWindow(gui, "Polygon from Contour", true);
////    }
//
//    public static VisionState process(BufferedImage image) {
//        GrayF32 input = ConvertBufferedImage.convertFromSingle(image, null, GrayF32.class);
//        GrayU8 binary = new GrayU8(input.width,input.height);
//        GrayS32 label = new GrayS32(input.width,input.height);
//
//        // Select a global threshold using Otsu's method.
//        GThresholdImageOps.threshold(input, binary, 30, false);
//
//        // Apply the threshold to create a binary image
////        ThresholdImageOps.threshold(input,binary,(float)threshold,true);
//
//        // remove small worms through erosion and dilation
//        // The null in the input indicates that it should internally declare the work image it needs
//        // this is less efficient, but easier to code.
//        GrayU8 filtered = BinaryImageOps.erode8(binary, 2, null);
////        filtered = BinaryImageOps.dilate8(filtered, 1, null);
//
//        // Detect worms inside the image using an 8-connect rule
//        List<Contour> contours = BinaryImageOps.contour(filtered, ConnectRule.EIGHT, label);
//
//        // colors of contours
//        int colorExternal = 0xFFFFFF;
//        int colorInternal = 0xFF2020;
//
//        // display the results
////        BufferedImage visualBinary = VisualizeBinaryData.renderBinary(binary, false, null);
////        BufferedImage visualFiltered = VisualizeBinaryData.renderBinary(filtered, false, null);
//
//        BufferedImage out = new BufferedImage(input.width, input.height, BufferedImage.TYPE_3BYTE_BGR);
//
////        VisualizeBinaryData.renderContours(contours, colorExternal, colorInternal,
////                input.width, input.height, out);
//
//        int[] colors = new int[contours.size() + 1];
//        Arrays.fill(colors, colorExternal);
//        colors[0] = 0;
//
//        VisualizeBinaryData.renderLabeled(label, colors, out);
//
////        return new VisionState(VisualizeBinaryData.renderLabeledBG(label, contours.size(), null), contours);
//        return new VisionState(out, contours);
//    }
//
//    public static void main( String args[] ) {
//        // load and convert the image into a usable format
//        BufferedImage image = UtilImageIO.loadImage(UtilIO.pathExample("C:\\Users\\Brian\\IdeaProjects\\WormsAI\\vision2.png"));
//
//        // convert into a usable format
//        GrayF32 input = ConvertBufferedImage.convertFromSingle(image, null, GrayF32.class);
//        GrayU8 binary = new GrayU8(input.width,input.height);
//        GrayS32 label = new GrayS32(input.width,input.height);
//
//        // Select a global threshold using Otsu's method.
//        GThresholdImageOps.threshold(input, binary, 30, false);
//
//        // Apply the threshold to create a binary image
////        ThresholdImageOps.threshold(input,binary,(float)threshold,true);
//
//        // remove small worms through erosion and dilation
//        // The null in the input indicates that it should internally declare the work image it needs
//        // this is less efficient, but easier to code.
//        GrayU8 filtered = BinaryImageOps.erode8(binary, 1, null);
//        filtered = BinaryImageOps.dilate8(filtered, 1, null);
//
//        // Detect worms inside the image using an 8-connect rule
//        List<Contour> contours = BinaryImageOps.contour(filtered, ConnectRule.EIGHT, label);
//
//        // colors of contours
//        int colorExternal = 0xFFFFFF;
//        int colorInternal = 0xFF2020;
//
//        // display the results
////        BufferedImage visualBinary = VisualizeBinaryData.renderBinary(binary, false, null);
////        BufferedImage visualFiltered = VisualizeBinaryData.renderBinary(filtered, false, null);
//        BufferedImage visualLabel = VisualizeBinaryData.renderLabeledBG(label, contours.size(), null);
////        BufferedImage visualContour = VisualizeBinaryData.renderContours(contours, colorExternal, colorInternal,
////                input.width, input.height, null);
//
////        ListDisplayPanel panel = new ListDisplayPanel();
////        panel.addImage(image, "Original");
////        panel.addImage(visualBinary, "Binary Original");
////        panel.addImage(visualFiltered, "Binary Filtered");
////        panel.addImage(visualLabel, "Labeled Blobs");
////        panel.addImage(visualContour, "Contours");
////        ShowImages.showWindow(panel,"Binary Operations",true);
//    }
//
//
//
//}
